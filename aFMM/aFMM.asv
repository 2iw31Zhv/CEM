% =========================================================================
% Aperiodic Fourier Modal Method
% =========================================================================
% Author: Ziwei Zhu
% =========================================================================
close all;
clear variables;

% define materials
mu0 = 1.0;
eps0 = 1.0;
mu_r = 1.0;
eps_r = 6.0;

% simulation region
Cx = 0.0; % cm
Cy = 0.0; % cm
Lx = 1.00; % cm
Ly = 1.00; % cm

% thickness
d = zeros(2, 1);
d(1) = 0.50; % cm
d(2) = 0.50; % cm


% define source
lambda0 = 10.00; % cm
k0  = 2.0 * pi / lambda0; % cm^-1
theta_src = 0; % arc
phi_src = pi / 4.0; % arc


n_inc = sqrt(eps0 / mu0);
k_inc = n_inc * [sin(theta_src) * cos(phi_src);
    sin(theta_src) * sin(phi_src);
    cos(theta_src)];


% grid parameters
Ny = 16;
Nx = ceil((Lx / Ly) * Ny);
dx = Lx / Nx;
dy = Ly / Ny;

% build the geometry of the device
ER = ones(Nx, Ny, 2);
UR = ones(Nx, Ny, 2);
% build device for layer 1
ER(:, :, 1) = eps_r;
UR(:, :, 1) = mu_r;
% build device for layer 2
ER(:, :, 2) = eps_r;
UR(:, :, 2) = mu_r;

% calculate the corresponding convolution matrix;

% number of harmonics
M = ceil(7 * Lx / lambda0);
if mod(M, 2) == 0
    M = M + 1; 
end
    
N = ceil(7 * Ly / lambda0);
if mod(N, 2) == 0
    N = N + 1;
end

ERC = zeros(M*N, M*N, 2);
URC = zeros(M*N, M*N, 2);

ERC(:, :, 1) = convmat(ER(:, :, 1), M, N);
ERC(:, :, 2) = convmat(ER(:, :, 2), M, N);

URC(:, :, 1) = convmat(UR(:, :, 1), M, N);
URC(:, :, 2) = convmat(UR(:, :, 2), M, N);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Main RCWA routines
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% setup wave number matrices
wavenumber = struct;
wavenumber.M = floor(M / 2);
wavenumber.N = floor(N / 2);
wavenumber.m = -wavenumber.M : wavenumber.M;
wavenumber.n = -wavenumber.N : wavenumber.N;

kxm = k_inc(1) - 2 * pi * wavenumber.m / k0 / Lx;
kyn = k_inc(2) - 2 * pi * wavenumber.n / k0 / Ly;

[Kyn, Kxm] = meshgrid(kyn, kxm);

Kz_ref = -conj(sqrt(conj(mu0) * conj(eps0) - Kxm.^2 - Kyn.^2));
Kz_trn = conj(sqrt(conj(mu0) * conj(eps0) - Kxm.^2 - Kyn.^2));

KX = diag(Kxm(:));
KY = diag(Kyn(:));
KZ_ref = diag(Kz_ref(:));
KZ_trn = diag(Kz_trn(:));

% compute eigen modes of free space (analyze gap medium)
% calculate W0, V0

W0 = eye(2*M*N);
Q0 = [KX * KY, eye(M*N) - KX * KX;
    KY * KY - eye(M*N), - KX * KY];
Kz0 = conj(sqrt(1.0 - Kxm.^2 - Kyn.^2));
KZ0 = diag(Kz0(:));
LAM0 = [1j * KZ0, zeros(M*N);
    zeros(M*N), 1j * KZ0];
V0 = Q0 / LAM0;


% initialize global s matrix
SG = struct;
SG.S11 = zeros(2*M*N);
SG.S12 = eye(2*M*N);
SG.S21 = eye(2*M*N);
SG.S22 = zeros(2*M*N);

% main loop through all layers
for i = 1 : 2
    % build eigen value problem
    ERi = ERC(:, :, i);
    URi = URC(:, :, i);
    
    Pi = [KX / ERi * KY, URi - KX / ERi * KX;
        KY / ERi * KY - URi, -KY / ERi * KX];
    Qi = [KX / URi * KY, ERi - KX / URi * KX;
        KY / URi * KY - ERi, -KY / URi * KX];
    
    % homogeneous layer code
%     Pi = full(1.0 / eps_r * [KX * KY, mu_r * eps_r * eye(M*N) - KX * KX;
%         KY * KY - mu_r * eps_r * eye(M*N), -KY * KX]);
%     Qi = eps_r / mu_r * Pi;
    
    OMEGA2 = Pi * Qi;
    
    [Wi, LAMi] = eig(OMEGA2);
    LAMi = sqrt(LAMi);
    Vi = Qi * Wi / LAMi;
    
    % calculate layer scatter matrix
    Ai0 = Wi \ W0 + Vi \ V0;
    Bi0 = Wi \ W0 - Vi \ V0;
    
    % should use expm instead of exp because exp(A) returns 1 for 0 entries
    % in A
    Xi = expm(-LAMi * k0 * d(i));
    
    
    S = struct;
    S.S11 = (Ai0 - Xi * Bi0 / Ai0 * Xi * Bi0)...
        \ (Xi * Bi0 / Ai0 * Xi * Ai0 - Bi0);
    S.S12 = (Ai0 - Xi * Bi0 / Ai0 * Xi * Bi0)...
        \ Xi * (Ai0 - Bi0 / Ai0 * Bi0);
    S.S21 = S.S12;
    S.S22 = S.S11;
    
    % update global scatter matrix
    SG = redheffer_star_product(SG, S);
    
end

% compute reflection side s matrix
Qref = 1.0 / mu0 * [KX * KY, mu0 * eps0 * eye(M*N) - KX * KX;
    KY * KY - mu0 * eps0 * eye(M*N), -KY * KX];
Wref = eye(2*M*N);
LAMref = [-1j * KZ_ref, zeros(M*N);
    zeros(M*N), -1j * KZ_ref];
Vref = Qref / LAMref;

Aref = W0 \ Wref + V0 \ Vref;
Bref = W0 \ Wref - V0 \ Vref;

SR = struct;
SR.S11 = - Aref \ Bref;
SR.S12 = 2.0 * inv(Aref);
SR.S21 = 0.5 * (Aref - Bref / Aref * Bref);
SR.S22 = Bref / Aref;

% compute transmission side s matrix
Qtrn = 1.0 / mu0 * [KX * KY, mu0 * eps0 * eye(M*N) - KX * KX;
    KY * KY - mu0 * eps0 * eye(M*N), -KY * KX];
Wtrn = eye(2*M*N);
LAMtrn = [1j * KZ_trn, zeros(M*N);
    zeros(M*N), 1j * KZ_trn];
Vtrn = Qtrn / LAMtrn;

Atrn = W0 \ Wtrn + V0 \ Vtrn;
Btrn = W0 \ Wtrn - V0 \ Vtrn;

ST = struct;
ST.S11 = Btrn / Atrn;
ST.S12 = 0.5 * (Atrn - Btrn / Atrn * Btrn);
ST.S21 = 2.0 * inv(Atrn);
ST.S22 = -Atrn \ Btrn;

% update global s matrix
SG = redheffer_star_product(SR, SG);
SG = redheffer_star_product(SG, ST);

% compute source
source = struct;

source.delta = zeros(M*N, 1);
source.delta(floor(N/2) * M + floor(M/2) + 1) = 1.0;

source.n = [0; 0; 1];
% for normal incidence
source.vTE = [0; 1; 0];
source.vTM = cross(k_inc, source.vTE);
source.vTM = source.vTM / norm(source.vTM);

source.theta = pi / 6.0;
source.P = cos(source.theta) * source.vTM + sin(source.theta) * source.vTE;

source.eT = [source.P(1) * source.delta;
    source.P(2) * source.delta];

% solve for reflected & transmitted field
c_src = Wref \ source.eT;
c_ref = SG.S11 * c_src;
c_trn = SG.S21 * c_src;

eT_ref = Wref * c_ref;
eT_trn = Wtrn * c_trn;

rx = eT_ref(1:M*N);
ry = eT_ref((M*N+1):2*M*N);
rz = - KZ_ref \ (KX * rx + KY * ry);

tx = eT_trn(1:M*N);
ty = eT_trn((M*N+1):2*M*N);
tz = - KZ_trn \ (KX * tx + KY * ty);

% calculate diffraction efficiencies
R2 = abs(rx).^2 + abs(ry).^2 + abs(rz).^2;
R = real(-KZ_ref / mu0) / real(k_inc(3) / mu0) * R2;
R = reshape(R, M, N);
REF = sum(R(:));

T2 = abs(tx).^2 + abs(ty).^2 + abs(tz).^2;
T = real(KZ_trn / mu0) / real(k_inc(3) / mu0) * T2;
T = reshape(T, M, N);
TRN = sum(T(:));

SUM = REF + TRN;

% verify conservation
fprintf('REF: %.3f, TRN: %.3f, SUM: %.3f\n', REF, TRN, SUM);





